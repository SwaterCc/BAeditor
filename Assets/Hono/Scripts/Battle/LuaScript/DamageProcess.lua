---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by shirui.
--- DateTime: 2024/8/27 下午2:14

--【【【配置】】】=======================================================================================================================================

ELogicAttr = CS.Hono.Scripts.Battle.ELogicAttr
local maxDamage = 999999

--【【【工具】】】=========================================================================================================================================
local function ElementDamage(attacker, target, damageInfo, damageConfig, damageArgs)
    local secondaryElementPen = 0
    local secondaryElementRed = 0
    local allElementPen = damageArgs.ElementPenPCT
    local allElementRed = damageArgs.ElementRedPCT

    if damageConfig.ElementType == CS.Hono.Scripts.Battle.EDamageElementType.Physical then
        secondaryElementPen = damageArgs.ElementPhysicalPenPCT / 10000
        secondaryElementRed = damageArgs.ElementPhysicalRedPCT / 10000
    elseif damageConfig.ElementType == CS.Hono.Scripts.Battle.EDamageElementType.Magic then
        secondaryElementPen = damageArgs.ElementMagicPenPCT / 10000
        secondaryElementRed = damageArgs.ElementMagicRedPCT / 10000
    end
    local result = (1 - secondaryElementRed + secondaryElementPen) + (allElementPen - allElementRed)
    return result
end

--【【【条件检测】】】======================================================================================================================================
local DamageModifierCondition = {

    CheckHitCount = function(attacker, target, damageInfo, params) --【判断伤害命中数量】
        -- addiParam[0] 右值，比较距离。左值是实际距离
        -- addiParam[1] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于

        --local HitCount = damageInfo.HitCount
        local HitCount = 3 --测试数据
        local result = CompareFunc[params[1]](HitCount, params[0])
        combineLog(result, "命中数量")

        return result
    end,

    CheckStat = function(attacker, target, damageInfo, params) --【属性绝对值对比】
        -- addiParam[0] 对象，0=攻击者，1=目标，2=定值
        -- addiParam[1] 属性ID
        -- addiParam[2] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于
        -- addiParam[3] 对象，0=攻击者，1=目标，2=定值
        -- addiParam[4] 属性ID

        local function GetStat(targetIndex)
            local TagetType = tonumber(params[targetIndex]) --获取对象类型，攻击者、目标、定值
            local StatID = tonumber(params[targetIndex + 1]) --获取左右各值的属性ID

            local GetStatValueByType = {
                [0] = function()
                    return attacker:GetAttrLua(StatID)
                end,
                [1] = function()
                    return target:GetAttrLua(StatID)
                end,
                [2] = function()
                    return StatID
                end,
            }

            return GetStatValueByType[TagetType]() --根据类型参数获取值
        end

        local result = CompareFunc[params[2]](GetStat(0), GetStat(3)) -- 比对左值和右值
        combineLog(result, "属性比较")
        return result
    end,

    CheckEnemyType = function(attacker, target, damageInfo, params) -- 【敌人强度类型】
        -- addiParam[0] 目标的强度类型
        -- addiParam[1] 布尔判断，0=是，1=否

        local enemyType = 2; --测试数据，敌人是boss
        local PrintTargetType = {
            [0] = function()
                return "普通敌人"
            end,
            [1] = function()
                return "精英"
            end,
            [2] = function()
                return "BOSS"
            end,
        }

        local function CompareEnemyType(bool)
            if bool == 0 then
                if enemyType == params[0] then
                    combineLog(true, "敌人类型")
                    return true
                else
                    combineLog(false, "敌人类型")
                end
            else
                combineLog(false, "敌人类型")
                return false
            end
        end

        if params.Count < 2 then
            return CompareEnemyType(0)
        else
            return CompareEnemyType(params[1])
        end
    end,

    CheckDistance = function(attacker, target, damageInfo, params) --【判断距离】
        -- addiParam[0] 右值，比较距离。左值是实际距离
        -- addiParam[1] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于

        local distance = 3; -- 获取相对距离，暂时没实现 local distance =  CS.UnityEngine.Vector3.Distance(attacker.position, target.position);
        local result = CompareFunc[params[1]](distance, params[0])
        combineLog(result, "判断距离")
        return result
    end,

    CheckDamageSourceType = function(attacker, target, damageInfo, params) --【判断伤害来源】
        -- addiParam[0] 如果伤害来源是此类型则
        -- addiParam[1] 布尔判断，0=是，1=否

        local damageSource = damageInfo.SourceType --获取伤害来源
        local PrintDamageSource = {
            [0] = function()
                return "技能"
            end,
            [1] = function()
                return "BUFF"
            end,
            [2] = function()
                return "子弹"
            end,
        }
        local function CompareDamageSource(bool)
            if bool == 0 then
                if damageSource == params[0] then
                    combineLog(true, "伤害类型")
                    return true
                end
            else
                combineLog(false, "伤害类型")
                return false
            end
        end
        if params.Count < 2 then
            return CompareDamageSource(0)
        else
            return CompareDamageSource(params[1])
        end

        return
    end,

    CheckTags = function(attacker, target, damageInfo, params) -- 【判断Tag】
        -- addiParam[0] 对象，0=攻击者，1=目标
        -- addiParam[1] TagID1
        -- addiParam[2] TagID2。。。表示and，必须同时满足给的所有tag
        local result = true
        for i = 1, params.Count - 1 do
            if not attacker:HasTag(params[i]) then
                result = false
                break
            end
        end
        combineLog(result, "Tag比较")
        return result
    end,

    CheckBuffByLayer = function(attacker, target, damageInfo, addiParam) --【判断BUFF】
        -- addiParam[0] 对象，0=攻击者，1=目标
        -- addiParam[1] A值，BUFFID
        -- addiParam[2] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于
        -- addiParam[3] 比较BUFF层数

        local buffLayer = 3; --测试数据

        local actor = (addiParam[0] == 1) and attacker or target
        local buffLayer = actor.BuffLayer(addiParam[1]); -- 还没实现获取对象BUFF层数，需要程序提供接口


        local result = CompareFunc[addiParam[2]](buffLayer, addiParam[3])
        combineLog(true, "属性比较")
        -- CS.UnityEngine.Debug.Log("目标：" ..tostring(actor) .."有ID【" ..addiParam[1] .. "】的BUFF->" .. buffLayer .. "层。" .. "   <color=#00FF00>BUFF层数匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
        return result
    end

}

DamageModifierCheckFunc = {
    [1] = DamageModifierCondition.CheckStat,
    [2] = DamageModifierCondition.CheckTags,
    [3] = DamageModifierCondition.CheckEnemyType,
    [4] = DamageModifierCondition.CheckDistance,
    [5] = DamageModifierCondition.CheckBuffByLayer,
    [6] = DamageModifierCondition.CheckDamageSourceType,
    [7] = DamageModifierCondition.CheckHitCount
}
--【【【预处理】】】=======================================================================================================================================
local DamageApplyModifier = {
    normal = function(attacker, target, damageInfo, ValueParams)
        return ValueParams[0] / 10000
    end,

    ex = function(attacker, target, damageInfo, ValueParams)

    end,
}

local damageArgs = {}
local FrontDamageProcess = function(attacker, target, damageInfo, damageConfig)       --【伤害计算前置流程，获取各项数值和预处理】
    --获取各项属性值并塞到列表里
    damageArgs.Level_Final = attacker:GetAttrLua(60010)                               --攻击者等级
    damageArgs.ATK_Final = attacker:GetAttrLua(12100)                                 --攻击力
    damageArgs.Def_Final = target:GetAttrLua(12110)                                   --防御力
    damageArgs.Skill_Per = damageInfo.BaseDamagePer / 10000                           --技能倍率
    damageArgs.DefIgnore_Final = attacker:GetAttrLua(12120)                           --护甲穿透
    damageArgs.DefIgnorePCT_Final = attacker:GetAttrLua(12120)                        --护甲穿透万分比
    damageArgs.Hp_Final = attacker:GetAttrLua(10000)                                  --当前生命
    damageArgs.Mp_Final = attacker:GetAttrLua(10020)                                  --当前奥义值
    damageArgs.CritChance = attacker:GetAttrLua(12140)                                --当前暴击率
    damageArgs.CritDamage = attacker:GetAttrLua(12150)                                --当前暴击伤害
    damageArgs.ElementPenPCT = attacker:GetAttrLuaByType(ELogicAttr.AttrElementPenPCT) --全属性抗性穿透
    damageArgs.ElementRedPCT = target:GetAttrLua(14010)                               --全属性抗性
    damageArgs.ElementPhysicalPenPCT = attacker:GetAttrLua(14020)                     --物理属性抗性穿透
    damageArgs.ElementPhysicalRedPCT = target:GetAttrLua(14030)                       --物理属性抗性
    damageArgs.ElementMagicPenPCT = attacker:GetAttrLua(14040)                        --元素属性抗性穿透
    damageArgs.ElementMagicRedPCT = target:GetAttrLua(14050)                          --元素属性抗性

    damageArgs.DmgRed = target:GetAttrLua(15300)                                      --直接减伤
    damageArgs.DmgRedNear = target:GetAttrLua(16020)                                  --近距离减伤
    damageArgs.DmgRedFar = target:GetAttrLua(16120)                                   --远距离减伤
    damageArgs.DmgRedBullet = target:GetAttrLua(16220)                                --子弹减伤
    damageArgs.DmgRedMelee = target:GetAttrLua(16320)                                 --近战减伤
    damageArgs.DmgRedBuff = target:GetAttrLua(16420)                                  --BUFF减伤
    damageArgs.DmgRedVsNormalEnemy = target:GetAttrLua(16720)                         --普通怪减伤
    damageArgs.DmgRedVsEliteEnemy = target:GetAttrLua(16820)                          --精英怪减伤
    damageArgs.DmgRedHealthy = target:GetAttrLua(17020)                               --健康减伤
    damageArgs.DmgRedNonHealthy = target:GetAttrLua(17120)                            --非健康减伤

    --防御减伤计算
    local DefRedFinal = math.max(0,
            1 - (damageArgs.Def_Final - damageArgs.DefIgnore_Final) /
                    ((damageArgs.Def_Final) + (damageArgs.Level_Final * 5 + 500)))


    --抗性减伤计算
    local EleResFinal = ElementDamage(attacker, target, damageInfo, damageConfig, damageArgs)
    --伤害减免计算
    local DamRedFinal = 1
    local AllDamRed = {
        DmgDistanceRed = function(attacker, target, damageInfo)
            local distance = 5;
            local currentDistance = 1
            local result = 1
            if CompareFunc[2](currentDistance, distance) then
                result = 1 - damageArgs.DmgRedFar / 10000
            else
                result = 1 - damageArgs.DmgRedNear / 10000
            end
            return result
        end,

        DamSkillType = function(attacker, target, damageInfo)
            local result = 1
            if damageInfo.SourceType == 0 then
                result = 1 - damageArgs.DmgRedMelee / 10000
            elseif damageInfo.SourceType == 1 then
                result = 1 - damageArgs.DmgRedBuff / 10000
            elseif damageInfo.SourceType == 2 then
                result = 1 - damageArgs.DmgRedBullet / 10000
            end
            return result
        end,

        DmgHealthyRed = function(attacker, target, damageInfo)
            local healthyPCT = 0.7;
            local nonHealthyPCT = 0.3;
            local result = 1
            local HpPct = target:GetAttrLua(10000) / target:GetAttrLua(10010)
            if HpPct >= healthyPCT then
                result = 1 - damageArgs.DmgRedHealthy / 10000
            elseif HpPct < nonHealthyPCT then
                result = 1 - damageArgs.DmgRedNonHealthy / 10000
            end
            return result
        end

    }
    for _, func in pairs(AllDamRed) do
        DamRedFinal = DamRedFinal * func(attacker, target, damageInfo)
    end

    --增伤最终修正【Part.1】 计算条件检测增伤
    local additiveFinal = 1;     --加区增伤
    for i, damageFuncInfo in pairs(damageConfig.AddiTypes) do
        local isPass = true
        for idx, cid in pairs(damageFuncInfo.ConditionIds) do
            local params = damageFuncInfo.ConditionParams[idx]
            local result = DamageModifierCheckFunc[cid.typeId](attacker, target, damageInfo, params)

            if not result then
                isPass = false
                --CS.UnityEngine.Debug.Log("伤害ID【" .. damageInfo.DamageConfigId .. "】：" .. logPart .. "<color=#FD6225>【本次附加增伤中断】</color>")
                --logPart = ""
                break
            end
        end

        if isPass and damageFuncInfo.ValueFuncName ~= nil then
            additiveFinal = additiveFinal +
                    DamageApplyModifier[damageFuncInfo.ValueFuncName](attacker, target, damageInfo,
                            damageFuncInfo.ValueParams)
            --CS.UnityEngine.Debug.Log("伤害ID【" .. damageInfo.DamageConfigId .. "】：" .. "<color=#00FF00>" .. logPart .. "</color>" .. "<color=#17F0FF>【【附加增伤乘区】】</color>-> " .. (additiveFinal * 100) .. "%")
            --logPart = ""
        end
    end

    local multiplyFinal = 1;     --乘区增伤
    for i, damageFuncInfo in pairs(damageConfig.MultiTypes) do
        local isPass = true
        for idx, cid in pairs(damageFuncInfo.ConditionIds) do
            local params = damageFuncInfo.ConditionParams[idx]
            local result = DamageModifierCheckFunc[cid](attacker, target, damageInfo, params)

            if not result then
                isPass = false
                break
            end
        end

        if isPass and damageFuncInfo.ValueFuncName ~= nil then
            multiplyFinal = multiplyFinal +
                    DamageApplyModifier[damageFuncInfo.ValueFuncName](attacker, target, damageInfo, damageFuncInfo.ValueParams)
            --CS.UnityEngine.Debug.Log("伤害ID【" .. damageInfo.DamageConfigId .. "】：" .. "<color=#00FF00>" .. logPart .. "</color>" .. "<color=#1726FF>【【乘法】】</color>-> " .. multiplyFinal)
        end
    end

    local CtirDmgFinal = 1;      --暴击
    damageArgs.CritDmgRate = 1;
    local IsCritical, CriticalValue = DamageProcess.CriticalProcess(attacker, target, damageInfo, damageArgs)
    if IsCritical then
        CtirDmgFinal = CriticalValue
        damageArgs.CritDmgRate = CtirDmgFinal
    end

    --增伤最终修正【Part.2】 apply条件增伤
    damageArgs.FinalAddi = additiveFinal                          --附加增伤最终修正（包含条件检测的值）
    damageArgs.FinalMulti = multiplyFinal                         --乘区增伤最终修正（包含条件检测的值）
    damageArgs.FinalRED = DefRedFinal * EleResFinal * DamRedFinal --承伤最终修正（包含条件检测的值）
end

--【【【主流程】】】=======================================================================================================================================
DamageProcess = {}
--计算暴击
DamageProcess.CriticalProcess = function(attacker, target, damageInfo, damageArgs, ExCritPara)
    local CritChance = attacker:GetAttrLua(12140) --当前暴击率
    local CritDamage = attacker:GetAttrLua(12150) --当前暴击值
    local CriticalValue = 10000

    math.randomseed(os.time())
    local randomValue = math.random(0, 10000)
    IsCritical = false
    if ExCritPara == -1 or damageInfo.SourceType == 2 then
        return false, CriticalValue
    elseif
    CritChance > randomValue or ExCritPara == 1 then
        IsCritical = true  --伤害暴击了
        CriticalValue = CritDamage --后续会增加条件暴击增伤，例：对脆弱目标造成暴击伤害增加500%
    end
    return true, CriticalValue / 10000
end

DamageProcess.DamageProcessMain = function(attacker, target, damageInfo, damageConfig)
    --初始化数据
    init(attacker, target, damageInfo, damageConfig)
    --【伤害计算前置流程，获取各项数值和预处理】
    FrontDamageProcess(attacker, target, damageInfo, damageConfig)
    --计算最终伤害
    local finalDamageValue = DamageFormula[damageConfig.FormulaName](attacker, target, damageInfo, damageConfig, damageArgs)
    --CS.UnityEngine.Debug.Log("伤害ID【"..damageInfo.DamageConfigId.."】：".."<color=#E8FF17>【【最终伤害】】</color>-> " .. finalDamageValue)

    --计算冲击

    --填充伤害结果
    local damageResult = CS.Hono.Scripts.Battle.DamageResults(finalDamageValue, IsCritical, 999)
    return damageResult
end

--【【【伤害计算】】】=======================================================================================================================================
--伤害计算方法
DamageFormula = {
    --普通伤害            
    NormalAttack = function(attacker, target, damageInfo, damageConfig, damageArgs, triggerParam)

        local finalDamageValue =
        damageArgs.ATK_Final *
                damageArgs.Skill_Per *
                damageArgs.FinalAddi *
                damageArgs.FinalMulti *
                damageArgs.CritDmgRate *
                damageArgs.FinalRED
        -- 伤害至少为1，最大为maxDamage
        local finalDamageValue = math.min(maxDamage, math.max(1, finalDamageValue))
        if triggerParam ~= 1 then
            logger.Info(
                    "<color=#F8B21B>DamageLog 元素:%s 最终伤害:<b>%s</b>  %s ID:%s  最终攻击力:%s * 技能倍率:%s * 附加增伤:%s * 乘区增伤:%s * 最终承伤:%s</color>",
                    string.sub(tostring(damageConfig.ElementType), 1, string.find(tostring(damageConfig.ElementType), " ") - 2),
                    math.floor(finalDamageValue),
                    logger.IntToStr(damageInfo.IsCritical, "<color=#F8471B>暴击</color>"),
                    damageInfo.SourceActorId,
                    damageArgs.ATK_Final,
                    damageArgs.Skill_Per,
                    damageArgs.FinalAddi,
                    damageArgs.FinalMulti,
                    damageArgs.FinalRED
            )
        end
        return finalDamageValue
    end,
    --目标生命百分比攻击
    AttackTargetPct = function(attacker, target, damageInfo, damageConfig, damageArgs)
        local targetMAXHP = target:GetAttrLua(10010)
        local finalDamageValue = damageArgs.Skill_Per * targetMAXHP
        logger.Info(
                "<color=#F8B21B>DamageLog 百分比伤害:<b>%s</b>  %s ID:%s  技能倍率:%s * 目标MAXHP:%s</color>",
                math.floor(finalDamageValue),
                logger.IntToStr(1, "<color=#1BCCF8>无法暴击</color>"),
                damageInfo.SourceActorId,
                tostring(damageArgs.Skill_Per * 100 .. "%"),
                targetMAXHP
        )
        return finalDamageValue
    end,
    --普通治疗
    Heal = function(attacker, target, damageInfo, damageConfig, damageArgs)

        local healAttack = attacker:GetAttrLuaByType(ELogicAttr.AttrAttack)    --DEMO2 治疗强度 = 攻击力
        local healUp = attacker:GetAttrLuaByType(ELogicAttr.AttrHeal) / 10000
        local beHealed = target:GetAttrLuaByType(ELogicAttr.AttrHealed) / 10000

        local finalDamageValue =
        (healAttack * damageArgs.Skill_Per) * (1 + beHealed + healUp) * damageArgs.CritDmgRate;
        logger.Info(
                "<color=#1DDD16>DamageLog 最终治疗:<b>%s</b>  %s ID:%s  最终治疗强度:%s * 技能倍率:%s * ( 1 + 治疗效果:%s + 被治疗效果:%s )</color>",
                math.floor(finalDamageValue),
                logger.IntToStr(damageInfo.IsCritical, "<color=#F8471B>暴击</color>"),
                damageInfo.SourceActorId,
                healAttack,
                damageArgs.Skill_Per,
                healUp,
                beHealed
        )

        return finalDamageValue
    end,
    --目标生命百分比治疗
    HealTargetPct = function(attacker, target, damageInfo, damageConfig, damageArgs)
        local targetMAXHP = target:GetAttrLua(10010)
        local finalDamageValue =
        damageArgs.Skill_Per * targetMAXHP
        logger.Info(
                "<color=#1DDD16>DamageLog 百分比治疗:<b>%s</b>  %s ID:%s  技能倍率:%s * 目标MAXHP:%s</color>",
                math.floor(finalDamageValue),
                logger.IntToStr(1, "<color=#1BCCF8>无法暴击</color>"),
                damageInfo.SourceActorId,
                tostring(damageArgs.Skill_Per * 100 .. "%"),
                targetMAXHP
        )
        return finalDamageValue
    end,
    --Dot伤害
    AttackBuffDot = function(attacker, target, damageInfo, damageConfig, damageArgs)
        --BUFF伤害不暴击
        damageArgs.CritDmgRate = 1
        --获取Buff层数
        --local dotCount = target:GetBuffLayer(damageConfig.SourceActorId) or 1 
        local dotCount = 5 or 1  --测试数据层数5
        --跑一次普通伤害计算
        local finalDamageValue = DamageFormula["NormalAttack"](attacker, target, damageInfo, damageConfig, damageArgs, 1)
        local finalDamageValue = finalDamageValue * math.max(1, dotCount)
        logger.Info(
                "<color=#F8B21B>DamageLog 元素:%s Dot总伤害:<b>%s</b>  单次伤害:%s  %s ID:%s  技能倍率:%s * BUFF层数:%s</color>",
                string.sub(tostring(damageConfig.ElementType), 1, string.find(tostring(damageConfig.ElementType), " ") - 2),
                math.floor(finalDamageValue),
                math.floor(finalDamageValue / math.max(1, dotCount)),
                logger.IntToStr(1, "<color=#1BCCF8>无法暴击</color>"),
                damageInfo.SourceActorId,
                tostring(damageArgs.Skill_Per * 100 .. "%"),
                dotCount
        )
        return finalDamageValue
    end,
    --分摊伤害
    AttackShare = function(attacker, target, damageInfo, damageConfig, damageArgs)
        --跑一次普通伤害计算
        local finalDamageValue = DamageFormula["NormalAttack"](attacker, target, damageInfo, damageConfig, damageArgs, 1)
        --根据命中人数数量分摊
        local finalDamageValue = math.max(1, finalDamageValue) / math.max(1, damageInfo.HitCount)
        logger.Info(
                "<color=#F8B21B>DamageLog 元素:%s 分摊后伤害:<b>%s</b>  分摊前伤害:%s  %s ID:%s  技能倍率:%s / 命中人数:%s</color>",
                string.sub(tostring(damageConfig.ElementType), 1, string.find(tostring(damageConfig.ElementType), " ") - 2),
                math.floor(finalDamageValue),
                math.floor(finalDamageValue * math.max(1, damageInfo.HitCount)),
                logger.IntToStr(1, "<color=#F8471B>暴击</color>"),
                damageInfo.SourceActorId,
                tostring(damageArgs.Skill_Per * 100 .. "%"),
                math.max(1, damageInfo.HitCount)
        )
        return finalDamageValue
    end,
}
