---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by shirui.
--- DateTime: 2024/8/27 下午2:14

local CompareFunc = {
    [1] = function(left, right)
        --大于
        if left == nil or right == nil then
            return false
        end
        return left > right
    end,
    [2] = function(left, right)
        --大于等于
        if left == nil or right == nil then
            return false
        end
        return left >= right
    end,
    [3] = function(left, right)
        --等于 
        if left == nil or right == nil then
            return false
        end
        return left == right
    end,
    [4] = function(left, right)
        --小于
        if left == nil or right == nil then
            return false
        end
        return left < right
    end,
    [5] = function(left, right)
        --小于等于
        if left == nil or right == nil then
            return false
        end
        return left <= right
    end,
}

local PrintCompareString = {
    [1] = function()
        return ">"
    end,
    [2] = function()
        return ">="
    end,
    [3] = function()
        return "=="
    end,
    [4] = function()
        return "<"
    end,
    [5] = function()
        return "<="
    end,
}

DamageAdditionalFunc = {
    -- 【属性对比】增伤
    [1] = function(attacker, target, damageInfo, addiParam)
        --CS.UnityEngine.Debug.Log(attacker.ShowAbility())
        return attacker:GetAttrLua(1) >= (addiParam[0])
    end,

    -- 【判断】增伤
    [2] = function(attacker, target, damageInfo, addiParam)

    end,

    -- 【敌人强度类型】增伤
    [3] = function(attacker, target, damageInfo, addiParam)

        -- addiParam[0] 左值，暂时没啥用
        -- addiParam[1] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于
        -- addiParam[2] 右值，目标的强度类型
        -- addiParam[3] 符合条件时的加值
        -- addiParam[4] 不符合条件时的加值

        --local leftValue = target:Type(addiParam[0]);
        local Type = 2;   --测试数据，敌人是boss
        local PrintTargetType = {
            [0] = function()
                return "普通敌人"
            end,
            [1] = function()
                return "精英"
            end,
            [2] = function()
                return "BOSS"
            end,
        }

        if Type == addiParam[2] then

            local result = addiParam[3] / 10000
            CS.UnityEngine.Debug.Log("判断 敌人类型是 " .. PrintTargetType[addiParam[2]]() .. "   <color=#00FF00>敌人类型匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result

        else
            local result = addiParam[4] / 10000
            CS.UnityEngine.Debug.Log("判断 敌人类型是 " .. PrintTargetType[addiParam[2]]() .. "   <color=#FF3A3A>敌人类型不匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result
        end
    end,

    -- 【判断距离】增减伤
    [4] = function(attacker, target, damageInfo, addiParam)

        -- addiParam[0] 左值，暂时没啥用
        -- addiParam[1] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于
        -- addiParam[2] 右值，比较距离
        -- addiParam[3] 符合条件时的加值
        -- addiParam[4] 不符合条件时的加值

        --暂时没实现 local distance =  CS.UnityEngine.Vector3.Distance(attacker.position, target.position);
        local distance = 3;

        if CompareFunc[addiParam[1]](distance, addiParam[2]) then

            local result = addiParam[3] / 10000
            CS.UnityEngine.Debug.Log("判断 实际距离" .. distance .. " 需要 " .. PrintCompareString[addiParam[1]]() .. " " .. "比较距离" .. addiParam[2] .. "   <color=#00FF00>距离匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result

        else
            local result = addiParam[4] / 10000
            CS.UnityEngine.Debug.Log("判断 实际距离" .. distance .. " 需要 " .. PrintCompareString[addiParam[1]]() .. " " .. "比较距离" .. addiParam[2] .. "   <color=#FF3A3A>距离不匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result
        end
    end,

    -- 【判断BUFF增减伤】
    [5] = function(attacker, target, damageInfo, addiParam)

        -- addiParam[0] 对象，0=攻击者，1=目标
        -- addiParam[1] A值，BUFFID
        -- addiParam[2] 比较符，1=大于，2=大于等于，3=等于，4=小于，5=小于等于
        -- addiParam[3] 比较BUFF层数
        -- addiParam[4] 符合条件时的加值
        -- addiParam[5] 不符合条件时的加值

        local BuffLayer = 3;  --测试数据

        local actor = (addiParam[0] == 1) and attacker or target
        -- 还没实现获取对象BUFF层数，需要程序提供接口
        -- local BuffLayer = actor.BuffLayer(addiParam[1]);  

        if CompareFunc[addiParam[2]](BuffLayer, addiParam[3]) then

            local result = addiParam[4] / 10000
            CS.UnityEngine.Debug.Log("目标：" .. tostring(actor) .. "有ID【" .. addiParam[1] .. "】的BUFF->" .. BuffLayer .. "层。" .. "   <color=#00FF00>BUFF层数匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result

        else
            local result = addiParam[5] / 10000
            CS.UnityEngine.Debug.Log("目标：" .. tostring(actor) .. "有ID【" .. addiParam[1] .. "】的BUFF->" .. BuffLayer .. "层。" .. "   <color=#FF3A3A>BUFF层数不匹配</color> 附加增伤乘区 " .. (result * 100) .. "%");
            return result
        end

    end,

    -- 【判断伤害来源】增伤
    [6] = function(attacker, target, damageInfo, addiParam)

        -- addiParam[0] 如果伤害来源是此类型则
        -- addiParam[1] 符合条件时的加值
        -- addiParam[2] 不符合条件时的加值

        --获取伤害来源
        local damageSource = damageInfo.SourceType
        local PrintDamageSource = {
            [0] = function()
                return "技能"
            end,
            [1] = function()
                return "BUFF"
            end,
            [2] = function()
                return "子弹"
            end,
        }


        --[[   
           if damageSource == addiParam[0] then
               local result = addiParam[1]/10000
               CS.UnityEngine.Debug.Log("判断 伤害来源是 "..PrintDamageSource[addiParam[0]]--[[().."   <color=#00FF00>伤害来源匹配</color> 附加增伤乘区 "..(result*100).."%");
            return result
        end
            local result = addiParam[2]/10000
            CS.UnityEngine.Debug.Log("判断 伤害来源是 "..PrintDamageSource[addiParam[0]]--[[().."   <color=#FF3A3A>伤害来源不匹配</color> 附加增伤乘区 "..(result*100).."%");
]]
        return damageSource == addiParam[0]
    end

}

DamageMultiplierFunc = {
    [1] = function(attacker, target, damageInfo, multiParam)

    end,

    [2] = function()

    end
}

DamageFormula = {
    normalAttack = function(damageArgs)
        return damageArgs.FinalAtk * damageArgs.FinalAddi * damageArgs.FinalMulti
    end,

    [2] = function()

    end,

    [3] = function()

    end,
}

EffectFuncs = {
    normal = function(attacker, target, damageInfo, ValueParams)
        return ValueParams[0]/10000
    end,

    ex = function(attacker, target, damageInfo, ValueParams)
      
    end,
}

DamageProcess = {}
--计算暴击
DamageProcess.CriticalProcess = function(attacker, target, damageInfo)
    return true, 1
end

DamageProcess.DamageProcessMain = function(attacker, target, damageInfo, damageConfig)
    --local damageConfig = CS.ConfigManager.Instance.Get("DamageConfig").GetRow(damageInfo.DamageConfigId)

    local additiveFinal = 1;
    for i, damageFuncInfo in pairs(damageConfig.AddiTypes) do
        local isPass = true
        for idx, cid in pairs(damageFuncInfo.ConditionIds) do
            local params = damageFuncInfo.ConditionParams[idx]
            local result = DamageAdditionalFunc[cid](attacker, target, damageInfo, params)

            if not result then
                isPass = false
                break
            end
        end

        if isPass and damageFuncInfo.ValueFuncName ~= nil then
            additiveFinal = additiveFinal + EffectFuncs[damageFuncInfo.ValueFuncName](attacker, target, damageInfo, damageFuncInfo.ValueParams)
        end
    end

    CS.UnityEngine.Debug.Log("<color=#17F0FF>【【附加增伤乘区】】</color>-> " .. (additiveFinal * 100) .. "%")

    local multiplyFinal = 1;
    for i, damageFuncInfo in pairs(damageConfig.AddiTypes) do
        local isPass = true
        for idx, cid in pairs(damageFuncInfo.ConditionIds) do
            local params = damageFuncInfo.ConditionParams[idx]
            local result = DamageAdditionalFunc[cid](attacker, target, damageInfo, params)

            if not result then
                isPass = false
                break
            end
        end

        if isPass and damageFuncInfo.ValueFuncName ~= nil then
            multiplyFinal = multiplyFinal + EffectFuncs[damageFuncInfo.ValueFuncName](attacker, target, damageInfo, damageFuncInfo.ValueParams)
        end
    end

    local IsCritical, CriticalValue = DamageProcess.CriticalProcess(attacker, target, damageInfo)

    if IsCritical then
        multiplyFinal = multiplyFinal * CriticalValue
    end

    local damageArgs = {
        FinalAtk = attacker:GetAttrLua(4),
        FinalAddi = additiveFinal,
        FinalMulti = multiplyFinal
    }

    --计算最终伤害
    local finalDamageValue = DamageFormula[damageConfig.FormulaName](damageArgs)

    --计算冲击

    --填充伤害结果
    local damageResult = CS.Hono.Scripts.Battle.DamageResults(finalDamageValue, true, 999)
    return damageResult
end
